---
title: "Group Project"
author: "Kayle Ransby"
date: "19/05/2021"
output: pdf_document
---

Load the libraries we require.

```{r message=FALSE, warning=FALSE}

library(tidyverse)
library(tidygraph)
library(igraph)
library(ggraph)

```


Here we load the tweet data into the `tweet_dataframe` variable.

```{r message=FALSE, warning=FALSE}

# Load tweet data
tweet_dataframe <- "Tweet file/tweets_cleaned_week.csv" %>%
  read_csv()

```


We intend on building the network based on the user_id, conversation_id and week variables; 
so filter out entries that have any of these variables empty.

```{r}
# Filter tweet data
tweet_dataframe <- tweet_dataframe %>% 
  filter(!is.na(user_id),
         !is.na(conversation_id),
         !is.na(week))
```


Here we are creating the links from the nodes (user_id) to the relations (conversation_id) as a bipartite network.
We also include the week of the tweet for later on.

We need to be sure that we only include one of each link, as a single user may have been part of the same conversation multiple times.

```{r}

# Retrieve bipartite links from dataframe
bipartite_links <- tweet_dataframe %>%
  select(user_id, conversation_id, week) %>%
  rename(to = user_id,from = conversation_id) %>%
  group_by(to, from, week) %>%
  slice(1) %>%
  ungroup()

```


Here we are converting from a bipartite to a unipartite network where users are linked to other users if they are part of the same conversation.
The week variable here is based on the from column.

```{r}

# Generate network from links
user_links <- bipartite_links %>%
  full_join(bipartite_links, by = c("from", "week")) %>%   # we are full_joining links with links, and connecting them via the columns from and week
  filter(to.x != to.y) %>%                                 # we don't care about self links
  select(-from) %>%                                        # we only care about the users, not the tweets now
  rename(from = to.x, to = to.y)                           # and we still want the from and to names for the columns

user_links <- user_links[, c('from', 'to', 'week')]        # change the order of the columns to make it easier to view

```


Create a graph object from the use_links dataframe for each week, and store it in the `weekly_network_graph` variable.

```{r}

  # dataframe list of the weekly network
weekly_network_dataframe <- data.frame(week=NA,
                                       name=NA,
                                       degree=NA,
                                       community=NA,
                                       transitivity=NA)

weekly_network_dataframe <- weekly_network_dataframe[FALSE,]

totalweeks <- 52     # Finishing week number
threshold <- 0.3     # Community detecting threshold

week_n_network <- function(n) {
  
  user_links %>%
    filter(week == n) %>%      # Change the week you want to filter here
    graph_from_data_frame(directed = FALSE) %>%
    as_tbl_graph() %>%
    filter(!node_is_isolated()) %>%              # Filtering the isolated nodes
    mutate(degree = centrality_degree(),         # Calculate the centrality of nodes on degree level
           community = group_louvain(),          # Group the nodes into communities
           transitivity = local_transitivity())  # Calculate the transitivity
  
}


#### Build weekly network, detect local communities by louvain method
for (n in 1:totalweeks){
  
  graph_data <- as_tibble(week_n_network(n))
  
  week <- rep(n, times = nrow(graph_data))
  
  # Save network to dataframe format
  weekly_network_dataframe <- rbind(weekly_network_dataframe, data.frame(week, graph_data))
  
}

```


find the father communities and son communities week by week

```{r message=FALSE, warning=FALSE}

# Data frame that trace the community life line
community_trace <- data.frame(week = NA, 
                              community_id = NA, 
                              community_id_related = NA,
                              relationship_type = NA)

community_trace <- community_trace[FALSE,]

get_highest_community <- . %>%
  select(community) %>% 
  max() %>%
  as.integer()

for (weeknum in 1:totalweeks) {
  
  # Get the community numbers from current week
  reptimebase <- weekly_network_dataframe %>%
    filter(week == weeknum) %>%
    get_highest_community()
    
  # Get the community numbers from next week
  if (weeknum < totalweeks) { # Not
    
    reptimenext <- weekly_network_dataframe %>%
      filter(week == weeknum + 1) %>%
      get_highest_community()
    
  } else {
    
    reptimenext <- 1
    
  }
  
  # Initial
  baseComm = 1
  nextComm = 1
  
  # Compare nodes in every community in current week and the week after
  for (baseComm in 1:reptimebase) {  
    
    nodes_current_community <- weekly_network_dataframe %>% 
      filter(week == weeknum) %>%
      filter(community == baseComm) %>% 
      select(name) 

    for (nextComm in 1:reptimenext) {
      if (weeknum < totalweeks) {
        
          nodes_nextweek_community <- weekly_network_dataframe %>% 
            filter(week == weeknum+1) %>%
            filter(community == nextComm) %>% 
            select(name) 
          
          ### Get the intersection of communities from current week and next week
          internodes <- intersect(nodes_current_community, nodes_nextweek_community)
          
          ### Calculate the proportion of intersection
          proportion <- count(internodes) / count(nodes_current_community)
          
          ### If proportion bigger than threshold:
          ### ---1, update the son_community for current week
          ### ---2, update the father_community value for next week community
          ### ---3, if it is the last week, finish the cooperation
          if (proportion > threshold){
            
            new_row = c(weeknum, baseComm, nextComm, "s")     ## "s" stands for son_community_type
            new_row1 = c(weeknum+1, nextComm, baseComm, "f")  ## "y" stands for father_community_type
            community_trace[nrow(community_trace) + 1,] = new_row
            community_trace[nrow(community_trace) + 1,] = new_row1
        }
      }
    }
  }
}

```

Save the father and son relationship between communities week by week, joined with the community level parameters, degrees / transitivity etc.
```{r}

currentweek_precictors <- data.frame(y = NA,
                                     ave_degree = NA,
                                     transitivity = NA,
                                     motif = NA,
                                     density = NA,
                                     community_id = NA,
                                     week = NA)

nextweek_predictors <- data.frame(next_y = NA,
                                  next_ave_degree = NA,
                                  next_transitivity = NA,
                                  next_motif = NA,
                                  next_density = NA,
                                  next_community_id = NA)


currentweek_precictors <- currentweek_precictors[FALSE,]
nextweek_predictors <- nextweek_predictors[FALSE,]

### Only display the relationship by current community to son community, filter the "s" type relationship
expected_community_trace <- community_trace %>% 
  filter(relationship_type == "s") 

repvalue <- expected_community_trace %>%
  nrow() %>%
  as.numeric()

for (n in 1:repvalue){
  
  # Get the current relationship's week number, community_id, son_community_id
  weeknum <- expected_community_trace[n,] %>%
    select(week) %>%
    as.integer()
  
  community_id <- expected_community_trace[n,] %>% 
    select(community_id) %>%
    as.integer()
  
  community_id_related <- expected_community_trace[n,] %>% 
    select(community_id_related) %>%
    as.integer()
  
  #### Current week:
  current_community_net <- week_n_network(weeknum)
  
  # Average degree:
  current_week_degree <- weekly_network_dataframe %>%
    filter(week == weeknum) %>%
    filter(community == community_id) %>%
    select(degree)
  
  ave_degree <- mean(current_week_degree$degree)
  
  # Transitivity:
  current_week_transitivity <- weekly_network_dataframe %>%
    filter(week == weeknum) %>%
    filter(community == community_id) %>%
    select(transitivity)
  
  transitivity <- mean(current_week_transitivity$transitivity)
  
  # Density
  density <- current_community_net %>%
    filter(community == community_id) %>%
    graph.density()
  
  
  # 3-motifs
  motif <- current_community_net %>%
    filter(community == community_id) %>%
    count_motifs(3)
  
  
  ## Expected y:
    
  # Number of edges
  exp_y <- current_community_net %>%
    filter(community == community_id) %>%
    igraph::gsize()
  
  # Number of nodes
  #exp_y <- current_community_net %>% 
  #  filter(community == community_id) %>%
  #  igraph::gorder()
  
  
  
  
  #### Next week:
  current_community_net <- week_n_network(weeknum+1)
  
  # Average degree:
  next_week_degree <- weekly_network_dataframe %>%
    filter(week == weeknum+1) %>%
    filter(community == community_id_related) %>%
    select(degree)
  
  next_ave_degree <- mean(next_week_degree$degree)
  
  # Transitivity:
  next_week_transitivity <- weekly_network_dataframe %>%
    filter(week == weeknum+1) %>%
    filter(community == community_id_related) %>%
    select(transitivity)
  
  next_transitivity <- mean(next_week_transitivity$transitivity)
  
  # Density
  next_density <- current_community_net %>%
    filter(community == community_id_related) %>%
    graph.density()
  
  
  # 3-motifs
  next_motif <- current_community_net %>%
    filter(community == community_id_related) %>%
    count_motifs(3)
  
  
  ## Expected y:
    
  # Number of edges
  next_y <- current_community_net %>%
    filter(community == community_id_related) %>%
    igraph::gsize()
  
  # Number of nodes
  #next_y <- current_community_net %>% 
  #  filter(community == community_id_related) %>%
  #  igraph::gorder()
  
  
  currentweek_precictors[nrow(currentweek_precictors) + 1,] <- c(exp_y, ave_degree, transitivity, motif, density, community_id, weeknum)
  nextweek_predictors[nrow(nextweek_predictors) + 1,] <- c(next_y, next_ave_degree, next_transitivity, next_motif, next_density, community_id_related)
  
}

# Join the add-on column into father-son relationship data frame 
predictors <- data.frame(currentweek_precictors, nextweek_predictors)

```


plot the graph for a certain week.
```{r}

week = 1
week_n_network(week) %N>%
    ggraph(layout = 'kk') + 
    geom_edge_link(show.legend = FALSE) + 
    geom_node_point(aes(color = as.factor(community)), size = 5) + 
    theme_graph()

```


Plot a single community from the given week
```{r}

week_n_network(week) %>%
  filter(community == 1) %N>%
  ggraph(layout = 'kk') + 
  geom_edge_link(show.legend = FALSE) + 
  geom_node_point(aes(color = as.factor(community)), size = 5) + 
  theme_graph()

```


Plot every week's graph in a .pdf file (Do not try to run this, it will not work for you)
```{r}

extrafont::loadfonts() # Prevents errors when building a pdf

pdf("weeks_NZ.pdf")
for (week in 1:52) {
  plt <- week_n_network(week) %N>%
    ggraph(layout = 'kk') + 
    geom_edge_link(show.legend = FALSE) + 
    geom_node_point(aes(color = as.factor(community)), size = 5) + 
    theme_graph()
  print(plt)
}
dev.off()

```


plot the whole network
```{r}
user_links %>% 
  ggraph(layout = 'stress') + 
  geom_edge_link(show.legend = FALSE) + 
  geom_node_point() +
  theme_graph()
```


Plot community elasticity
```{r}

community_graph <- community_trace %>%
  filter(relationship_type == "s") %>%
  select(week, community_id, community_id_related) %>%
  rename(to = community_id, from = community_id_related)


community_graph <- community_graph[, c("to", "from", "week")]

community_network <- community_graph %>%
    graph_from_data_frame(directed = FALSE) %>%
    as_tbl_graph()

community_network %>%
  ggraph() + 
  geom_edge_link(show.legend = FALSE) + 
  geom_node_point(size = 5)# + 
  #theme_graph()

```

