  
---
title: "Group Project"
author: "Kayle Ransby"
date: "19/05/2021"
output: pdf_document
---

Load the libraries we require.

```{r message=FALSE, warning=FALSE}

library(tidyverse)
library(tidygraph)
library(igraph)
library(ggraph)

```


Here we load the tweet data into the ```tweet_dataframe``` variable.

```{r message=FALSE, warning=FALSE}

# Load tweet data
tweet_dataframe <- "Tweet file/tweets_cleaned_week.csv" %>%
  read_csv()

```


We intend on building the network based on the user_id and conversation_id variables; 
so filter out any entries that have either variable empty.

```{r}
# Filter tweet data
tweet_dataframe <- tweet_dataframe %>% 
  filter(!is.na(user_id),
         !is.na(conversation_id),
         !is.na(week))
```


Here we are creating the links from the nodes (user_id) to the relations (conversation_id) as a bipartite network.
We also include the week of the tweet for later on.

```{r}

# Retrieve bipartite links from dataframe
bipartite_links <- tweet_dataframe %>%
  select(user_id, conversation_id, week) %>%
  rename(to = user_id,from = conversation_id) %>%
  group_by(to, from, week) %>%
  slice(1) %>%
  ungroup()

```


Here we are converting from a bipartite to a unipartite network where users are linked to other users if they are part of the same conversation.
The week variable here is based on the from column.

```{r}
# generate network from links
user_links <- bipartite_links %>%
    full_join(bipartite_links, by = c("from", "week")) %>%   # we are full_joining links with links, and connecting them via the column from
    filter(to.x != to.y) %>%            # we don't care about self links
    select(-from) %>%                   # we only care about the users, not the tweets now
    rename(from = to.x, to = to.y)      # and we still want the from and to names for the columns

user_links <- user_links[, c('from', 'to', 'week')] # change the order of the columns to make it easer to view
```


Create a graph object from the use_links dataframe; filtering by week 52.

```{r}
# tweet_network <- user_links %>%
#     filter(week == 52) %>%      # Change the week you want to filter here
#     graph_from_data_frame(directed = FALSE) %>%
#     as_tbl_graph()

weekly_network_graph     <- list()  # tidygraph list of the weekly network 
weekly_network_dataframe <- list()  # dataframe list of the weekly network 

weeknum =1        #Starting week number
totalweeks =52    #finishing week number
threshold=0.3     #community detecting threshold


####build weekly network, detect local communities by louvain method
n=1
for (n in 1:totalweeks){
  
  tweet_network <- user_links %>%
    filter(week == n) %>%      # Change the week you want to filter here
    graph_from_data_frame(directed = FALSE) %>%
    as_tbl_graph()
  
  #community detection
  weekly_network_graph[[n]] <- tweet_network %>%
    activate(nodes) %>%
    filter(!node_is_isolated()) %>% #filtering the isolated nodes
    mutate(degree = centrality_degree(),         #Calculate the centrality of nodes on degree level
           community = group_louvain(),          #Group the nodes into communities
           transitivity = local_transitivity(),  #calculate the transitivity
           modularity = graph_modularity(community))    # Calculate the community's modularity

           # father_community = list(),               #initial father community
           # son_community = list())                  #initial son community
           # 
  
  #save network to dataframe format
  weekly_network_dataframe[[n]] <- as_tibble(weekly_network_graph[[n]])
}

```


find the father communities and son communities week by week

```{r message=FALSE, warning=FALSE}
##data frame that trace the community life line
community_trace <- data.frame(week_id=1,community_id=2,community_id_related =3,relationship_type=4)

for (weeknum in 1:totalweeks){
  
  #get the commmunity numbers from current week
  reptimebase <- weekly_network_dataframe[[weeknum]] %>% 
    arrange(desc(community)) %>% 
    select(community) %>% 
    top_n(1) %>% 
    unique()%>% 
    as.integer()
  
  #get the community numbers from next week
  if (weeknum < totalweeks){#not
    reptimenext <- weekly_network_dataframe[[weeknum+1]] %>% 
      arrange(desc(community)) %>% 
      select(community) %>% 
      top_n(1) %>% 
      unique() %>% 
      as.integer()
  }else
    reptimenext <- 1
  
  #initial
  n=1
  m=1
  l=1
  proportion <- list()
  
  #Compare nodes in every community in current week and the week after
  for (n in 1:reptimebase){  
    
    nodes_current_community <- weekly_network_dataframe[[weeknum]] %>% 
      filter(community == n) %>% 
      select(name) 

    for (m in 1:reptimenext){
      if (weeknum < totalweeks){
        
          nodes_nextweek_community <- weekly_network_dataframe[[weeknum+1]] %>% 
            filter(community == m) %>% 
            select(name) 
          
          ### get the intersection of communities from current week and next week
          internodes <- intersect(nodes_current_community,nodes_nextweek_community) 
          ### calculate the proportion of intersection
          proportion <- c(proportion,count(internodes)/count(nodes_current_community))
          
          ### if proportion bigger than threshold:
          ### ---1, update the son_community for current week
          ### ---2, update the father_community value for next week community
          ### ---3, if it is the last week, finish the cooperation
          if (proportion[[l]] > threshold){
            
            new_row = c(weeknum, n, m, "s")     ##"s" stands for son_community_type
            new_row1 = c(weeknum+1, m, n, "f")  ##"y" stands for father_community_type
            community_trace[nrow(community_trace) + 1,] = new_row
            community_trace[nrow(community_trace) + 1,] = new_row1
        }
        l=l+1
      }
    }
  }
}
```

Save the father and son relationship between communities week by week, joined with the community level parameters, degrees / transitivity etc.
```{r}
currentweek_degree <- data.frame(currentweek_degree=1)
currentweek_transitivity<- data.frame(currentweek_transitivity=1)
nextweek_degree<- data.frame(nextweek_degree=1)
nextweek_transitivity<- data.frame(nextweek_transitivity=1)

###only display the relationship by current community to son community, filter the "s" type relationship
expected_community_trace <- 
  community_trace%>% 
  filter(relationship_type == "s") 

repvalue <- as.numeric(nrow(expected_community_trace))

n=1
 # weeknum <- expected_community_trace[n,]$week_id
for (n in 1:repvalue){
  
  #get the current relationship's week number, community_id, son_community_id
  weeknum <- expected_community_trace[n,]$week_id %>% as.integer()
  community_id <- expected_community_trace[n,]$community_id %>% as.integer()
  community_id_related<- expected_community_trace[n,]$community_id_related  %>% as.integer()
  
  #calculate average degree/transitivity for current week community
  current_week_degree <- weekly_network_dataframe[[weeknum]][weekly_network_dataframe[[weeknum]]$community==community_id, "degree"]
  current_week_transitivity <- weekly_network_dataframe[[weeknum]][weekly_network_dataframe[[weeknum]]$community==community_id, "transitivity"]
  curren_degree_mean        <- mean(current_week_degree$degree)
  current_transitivity_mean <- mean(current_week_transitivity$transitivity)
  
  #calculate average degree/transitivity for next week community
  next_week_degree <- weekly_network_dataframe[[weeknum+1]][weekly_network_dataframe[[weeknum+1]]$community==community_id_related, "degree"]
  next_week_transitivity <- weekly_network_dataframe[[weeknum+1]][weekly_network_dataframe[[weeknum+1]]$community==community_id_related, "transitivity"]
  next_degree_mean          <- mean(next_week_degree$degree)
  next_transitivity_mean    <- mean(next_week_transitivity$transitivity)
  
  currentweek_degree[n,1] <- curren_degree_mean
  currentweek_transitivity[n,1] <- current_transitivity_mean
  nextweek_degree[n,1] <- next_degree_mean
  nextweek_transitivity[n,1] <- next_transitivity_mean
}

#join the add-on column into father-son relationship data frame 
expected_community_trace <- cbind(expected_community_trace,currentweek_degree,currentweek_transitivity,nextweek_degree,nextweek_transitivity)

```


```{r}
weekly_network_dataframe
```



check the community plot for certain week.
```{r}
week = 1
weekly_network_graph[[week]] %N>%
    ggraph(layout = 'kk') + 
    geom_edge_link(show.legend = FALSE) + 
    geom_node_point(aes(color = as.factor(community)), size = 5) + 
    theme_graph()

```

plot the whole network
```{r}
user_links %>% 
    ggraph(layout = 'stress') + 
    geom_edge_link(show.legend = FALSE) + 
    geom_node_point() +
    theme_graph()
```
Transform community rejections
```{r}


```

