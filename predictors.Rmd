---
title: "Group Project"
author: "Kayle Ransby"
date: "19/05/2021"
output: pdf_document
---

Load the libraries we require.

```{r message=FALSE, warning=FALSE}

library(tidyverse)
library(tidygraph)
library(igraph)
library(ggraph)

```


Here we load the tweet data into the `tweet_dataframe` variable.

```{r message=FALSE, warning=FALSE}

# Load tweet data
tweet_dataframe <- "Tweet file/tweets_cleaned_week.csv" %>%
  read_csv()

```


We intend on building the network based on the user_id, conversation_id and week variables; 
so filter out entries that have any of these variables empty.

```{r}
# Filter tweet data
tweet_dataframe <- tweet_dataframe %>% 
  filter(!is.na(user_id),
         !is.na(conversation_id),
         !is.na(week))
```


Here we are creating the links from the nodes (user_id) to the relations (conversation_id) as a bipartite network.
We also include the week of the tweet for later on.

```{r}

# Retrieve bipartite links from dataframe
bipartite_links <- tweet_dataframe %>%
  select(user_id, conversation_id, week) %>%
  rename(to = user_id,from = conversation_id) %>%
  group_by(to, from, week) %>%
  slice(1) %>%
  ungroup()

```


Here we are converting from a bipartite to a unipartite network where users are linked to other users if they are part of the same conversation.
The week variable here is based on the from column.

```{r}

# Generate network from links
user_links <- bipartite_links %>%
  full_join(bipartite_links, by = c("from", "week")) %>%   # we are full_joining links with links, and connecting them via the columns from and week
  filter(to.x != to.y) %>%                                 # we don't care about self links
  select(-from) %>%                                        # we only care about the users, not the tweets now
  rename(from = to.x, to = to.y)                           # and we still want the from and to names for the columns

user_links <- user_links[, c('from', 'to', 'week')]        # change the order of the columns to make it easier to view

```


Create a graph object from the use_links dataframe; filtering by week 52.

```{r}

weekly_network_graph     <- list()  # tidygraph list of the weekly network 
weekly_network_dataframe <- list()  # dataframe list of the weekly network 

weeknum = 1         # Starting week number
totalweeks = 52     # Finishing week number
threshold = 0.3     # Community detecting threshold


#### Build weekly network, detect local communities by louvain method
for (n in 1:totalweeks){
  
  tweet_network <- user_links %>%
    filter(week == n) %>%      # Change the week you want to filter here
    graph_from_data_frame(directed = FALSE) %>%
    as_tbl_graph()
  
  # Community detection
  weekly_network_graph[[n]] <- tweet_network %>%
    filter(!node_is_isolated()) %>%              # Filtering the isolated nodes
    mutate(degree = centrality_degree(),         # Calculate the centrality of nodes on degree level
           community = group_louvain(),          # Group the nodes into communities
           transitivity = local_transitivity(),  # Calculate the transitivity
           modularity = graph_modularity(community))    # Calculate the community's modularity
  
  
  # Save network to dataframe format
  weekly_network_dataframe[[n]] <- as_tibble(weekly_network_graph[[n]])
}

```


find the father communities and son communities week by week

```{r message=FALSE, warning=FALSE}

# Data frame that trace the community life line
community_trace <- data.frame(week_id = 1, 
                              community_id = 2, 
                              community_id_related = 3, 
                              relationship_type = 4)

get_highest_community <- . %>%
  arrange(desc(community)) %>% 
  select(community) %>% 
  max() %>%
  as.integer()

for (weeknum in 1:totalweeks) {
  
  # Get the community numbers from current week
  reptimebase <- weekly_network_dataframe[[weeknum]] %>%
    get_highest_community()
    
  # Get the community numbers from next week
  if (weeknum < totalweeks) { # Not
    reptimenext <- weekly_network_dataframe[[weeknum+1]] %>%
      get_highest_community()
    
  } else {
    reptimenext <- 1
  }
  
  # Initial
  baseComm = 1
  nextComm = 1
  l = 1
  proportion <- list()
  
  # Compare nodes in every community in current week and the week after
  for (baseComm in 1:reptimebase) {  
    
    nodes_current_community <- weekly_network_dataframe[[weeknum]] %>% 
      filter(community == baseComm) %>% 
      select(name) 

    for (nextComm in 1:reptimenext) {
      if (weeknum < totalweeks) {
        
          nodes_nextweek_community <- weekly_network_dataframe[[weeknum+1]] %>% 
            filter(community == nextComm) %>% 
            select(name) 
          
          ### Get the intersection of communities from current week and next week
          internodes <- intersect(nodes_current_community, nodes_nextweek_community)
          
          ### Calculate the proportion of intersection
          proportion <- c(proportion, count(internodes)/count(nodes_current_community))
          
          ### If proportion bigger than threshold:
          ### ---1, update the son_community for current week
          ### ---2, update the father_community value for next week community
          ### ---3, if it is the last week, finish the cooperation
          if (proportion[[l]] > threshold){
            
            new_row = c(weeknum, baseComm, nextComm, "s")     ## "s" stands for son_community_type
            new_row1 = c(weeknum+1, nextComm, baseComm, "f")  ## "y" stands for father_community_type
            community_trace[nrow(community_trace) + 1,] = new_row
            community_trace[nrow(community_trace) + 1,] = new_row1
        }
        l=l+1
      }
    }
  }
}

```

Save the father and son relationship between communities week by week, joined with the community level parameters, degrees / transitivity etc.
```{r}

currentweek_degree <- data.frame(currentweek_degree=1)
currentweek_transitivity <- data.frame(currentweek_transitivity=1)
nextweek_degree <- data.frame(nextweek_degree=1)
nextweek_transitivity <- data.frame(nextweek_transitivity=1)

### Only display the relationship by current community to son community, filter the "s" type relationship
expected_community_trace <- community_trace %>% 
  filter(relationship_type == "s") 

repvalue <- expected_community_trace %>%
  nrow() %>%
  as.numeric()

for (n in 1:repvalue){
  
  # Get the current relationship's week number, community_id, son_community_id
  weeknum <- expected_community_trace[n,] %>%
    select(week_id) %>%
    as.integer()
  
  community_id <- expected_community_trace[n,] %>% 
    select(community_id) %>%
    as.integer()
  
  community_id_related <- expected_community_trace[n,] %>% 
    select(community_id_related) %>%
    as.integer()
  
  # Calculate average degree/transitivity for current week community
  current_week_degree <- weekly_network_dataframe[[weeknum]][weekly_network_dataframe[[weeknum]]$community == community_id, "degree"]
  current_week_transitivity <- weekly_network_dataframe[[weeknum]][weekly_network_dataframe[[weeknum]]$community == community_id, "transitivity"]
  curren_degree_mean        <- mean(current_week_degree$degree)
  current_transitivity_mean <- mean(current_week_transitivity$transitivity)
  
  # Calculate average degree/transitivity for next week community
  next_week_degree <- weekly_network_dataframe[[weeknum+1]][weekly_network_dataframe[[weeknum+1]]$community == community_id_related, "degree"]
  next_week_transitivity <- weekly_network_dataframe[[weeknum+1]][weekly_network_dataframe[[weeknum+1]]$community == community_id_related, "transitivity"]
  next_degree_mean          <- mean(next_week_degree$degree)
  next_transitivity_mean    <- mean(next_week_transitivity$transitivity)
  
  currentweek_degree[n,1] <- curren_degree_mean
  currentweek_transitivity[n,1] <- current_transitivity_mean
  nextweek_degree[n,1] <- next_degree_mean
  nextweek_transitivity[n,1] <- next_transitivity_mean
}

# Join the add-on column into father-son relationship data frame 
expected_community_trace <- cbind(expected_community_trace, currentweek_degree, currentweek_transitivity, nextweek_degree, nextweek_transitivity)

```


```{r}
weekly_network_dataframe
```



check the community plot for certain week.
```{r}
week = 1
weekly_network_graph[[week]] %N>%
    ggraph(layout = 'kk') + 
    geom_edge_link(show.legend = FALSE) + 
    geom_node_point(aes(color = as.factor(community)), size = 5) + 
    theme_graph()

```


Plot every week's graph in a .pdf file (Do not try to run this, it will not work for you)
```{r}
extrafont::loadfonts() # Prevents errors when building a pdf

pdf("weeks_NZ.pdf")
for (week in 1:52) {
  plt <- weekly_network_graph[[week]] %N>%
    ggraph(layout = 'kk') + 
    geom_edge_link(show.legend = FALSE) + 
    geom_node_point(aes(color = as.factor(community)), size = 5) + 
    theme_graph()
  print(plt)
}
dev.off()

```


plot the whole network
```{r}
user_links %>% 
    ggraph(layout = 'stress') + 
    geom_edge_link(show.legend = FALSE) + 
    geom_node_point() +
    theme_graph()
```

